## 1. 从开天辟地🪓说起（指xv6到底是如何一步步run起来的）
~~（当然这是来自lab1和lab2的拷打）~~
- 在你按照lab1的要求（~~make qemu~~）成功跑起来xv6以后，很理所当然的就想知道：“哇，这玩意如何一步步链接在一起然后跳出  **：**  让我输入命令的。“那么恭喜你，你将踏上一条~~不归之路~~变强的路。
	- 那么从sleep开始：
		- 已知xv6是用C混合汇编写出来的东西，那么理所当然的就要有来自Makefile的拷打
		 [《跟我一起写makefile》_haoel的博客-CSDN博客](https://blog.csdn.net/haoel/article/details/2886)
		 - ~~当然，你不会也没关系啦，只要和我一起抄~~加油~~就可以啦。什么，你说不知道GUN make，Makefile或者Cmake？那你要不试试再问问度娘或者必应娘？毕竟我也不会的说QWQ~~
	 - 想要完成这个part，首先就要给Makefile内加入你要构建的sleep，像这样：$U/_sleep\
		- 既然你知道了makefile这个东西，不妨现在就去看看里面都要什么，是不是有很多文件调用名？~~你但凡看一眼上面的链接也不会轻易听信我这个没看过的人的概况~~。你说有什么用？作用就是把你现在xv6 lab下面的文件按照开发者的要求和规则拼到一起~~（很潦草的描述不是吗）~~。
- 但是问题来了，光是把文件拼到一起还是不够的，一个个文件先运行谁后运行谁该如何得知呢？这就要从lab2说起了：
	- 已知你手里的xv6是用一个个文件拼起来的，而每个文件里面都有各种函数和各种调用，而他们中的一部分叫做：system call
		- 现在你要知道：一个操作系统是需要把用户进程和内核进程隔离开的，但用户是绝对不甘心的，毕竟读写磁盘（需要进入内核的一种情况）是绝对不能放弃的~~（谁能拒绝给磁盘里塞（）（）（）呢）~~，这时候用户必定要狠狠访问内核，但又不能直接进去，这时候就要请出大法：**跳板函数** 了。
		- syscall.c和syscall.h分别放着系统调用的具体代码和他们的调用名字（函数名）表，在你需要加入系统调用的时候就必须在两个里面都写好~~（不要生黑户）~~。还有sysinfo.h文件里面也要加声明（坑）
		- 但是系统调用是有这个娃（函数）了，也在.h文件里面编号（上户）了，可我用户怎么知道，难不成去开挂抢~~（潜入办公室）~~？这时候就要有syscall.c里面的extern 全局声明了:
		> 	用 extern 全局声明新的内核调用函数，并且在 syscalls 映射表中，加入从前面定义的编号到系统调用函数指针的映射extern uint64 sys_trace(void);   [SYS_trace] sys_trace,
		- 当然还没完，在usys.pl里面还要加入用户态到内核态的跳板函数：
		> 	这个脚本在运行后会生成 usys.S 汇编文件，里面定义了每个 system call 的用户态跳板函数 entry("函数名");
		- 还没完啊还没完，在用户态的头文件user.h加入定义，使得用户态程序可以找到这个跳板入口函数。int 函数名(int);
	- 这下子完成了，总结起来就是：
	> 	user/user.h: 用户态程序调用跳板函数 trace() 
	> 	user/usys.S: 跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态 
	> 	kernel/syscall.c 到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
	> 	kernel/syscall.c syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。 
	> 	kernel/sysproc.c 到达 sys_trace() 函数，执行具体内核操作
	- 说人话版：用户态下查表找到要调用的内核函数名字，让跳板函数带着这个名字跳进内核态统一处理，到内核态以后再查表，查到以后就可以调用了~~（是不是很简单）~~
	>	这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。
	>	并且由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。
	>	同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。（在本 lab 第二个实验会用到）
- 少年啊，你已经知道这些文件里面的函数是如何串起来的了，但是似乎少了些什么，对！我们现在知道的只是基于xv6跑起来以后的事，但是它是如何从未读取的硬盘数据跑起来的呢？（[课程3.9](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec03-os-organization-and-system-calls/3.9-xv6-qi-dong-guo-cheng)部分和[附录 B：引导加载器](https://xv6-chinese.readthedocs.io/zh/latest/docs/AppendixB.html)有详细说明，以下只是基于我个人理解的总结）
	> 当我们启动电脑，内存会加载硬盘上固定位置的一段代码（BOIS），它会检查你PC的全身硬件，然后把另一段（操作系统斟茶兵 boot loader）加载到内存中，然后斟茶兵会把系统内核从硬盘上再拉到内存里开始运行。（省略了所有细节，请详细学习上述两链接内容！）
	> 内核有了，下一步就要创建用户态程序了，毕竟不能让你霍霍内核（乐），userinit会创建初始进程并返回用户空间，（此处省去巴拉巴拉调用）然后你的shell就运行起来了。（突兀的结束）
- 什么，太长不看？(っ °Д °;)っ
省流版：你的PC调用了一堆被按照要求整理好的文件。
## 2.从水下第一个生命的萌芽开始……到内存控制🤪
~~（然后这就是lab3)的内容~~
- 如果说前两个实验是让你概览，那么下一个就是从内存的第一块数据说起了
	- xv6辣么多代码，他是怎么储存的呢，又是如何给每个运行的程序分配内存的呢：
		>	RISC-V 的逻辑地址寻址是采用三级页表的形式，9 bit 一级索引找到二级页表，9 bit 二级索引找到三级页表，9 bit 三级索引找到内存页，最低 12 bit 为页内偏移（即一个页 4096 bytes）。
	-  按照要求来，让我们扒开他的三级页表看看 ![[f2-1.png]]
	- 好复杂，看不懂怎么办，那就请阅读[xv6book 页表](https://xv6-chinese.readthedocs.io/zh/latest/docs/chapter2.html) 。其实就是上半张图，三个箭头从左到右理解为目录一，目录二，偏移量（行数字数位置）即可。
- 你都知道他里面是什么东西了，这不自己做一个试试？要知道，原本的xv6里面是全家共享的页表，~~进程长大了给孩子留点隐私吧~~，下个部分就是让每一个进程进入内核态后，都能有自己的独立**内核页表**
	- 众所周知，C语言想组织起有联系的数据就会用结构体，既然这样，在进程的结构体里面加上独属于它的内核页表~~（房间）~~不就可以了吗？
	- 但是问题是：原本的房子（内存分配）是没有这种考虑的，而内存分配是要由系统帮助的，那么我们就去自己加上（大改）分配函数