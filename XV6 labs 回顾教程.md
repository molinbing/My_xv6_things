## 1. 从开天辟地🪓说起（指xv6到底是如何一步步run起来的）
~~（当然这是来自lab1和lab2的拷打）~~
- 在你按照lab1的要求（~~make qemu~~）成功跑起来xv6以后，很理所当然的就想知道：“哇，这玩意如何一步步链接在一起然后跳出  **：**  让我输入命令的。“那么恭喜你，你将踏上一条~~不归之路~~变强的路。
	- 那么从sleep开始：
		- 已知xv6是用C混合汇编写出来的东西，那么理所当然的就要有来自Makefile的拷打
		 [《跟我一起写makefile》_haoel的博客-CSDN博客](https://blog.csdn.net/haoel/article/details/2886)
		 - ~~当然，你不会也没关系啦，只要和我一起抄~~加油~~就可以啦。什么，你说不知道GUN make，Makefile或者Cmake？那你要不试试再问问度娘或者必应娘？毕竟我也不会的说QWQ~~
	 - 想要完成这个part，首先就要给Makefile内加入你要构建的sleep，像这样：$U/_sleep\
		- 既然你知道了makefile这个东西，不妨现在就去看看里面都要什么，是不是有很多文件调用名？~~你但凡看一眼上面的链接也不会轻易听信我这个没看过的人的概况~~。你说有什么用？作用就是把你现在xv6 lab下面的文件按照开发者的要求和规则拼到一起~~（很潦草的描述不是吗）~~。
- 但是问题来了，光是把文件拼到一起还是不够的，一个个文件先运行谁后运行谁该如何得知呢？这就要从lab2说起了：
	- 已知你手里的xv6是用一个个文件拼起来的，而每个文件里面都有各种函数和各种调用，而他们中的一部分叫做：^system call ^4ea47d
		- 现在你要知道：一个操作系统是需要把用户进程和内核进程隔离开的，但用户是绝对不甘心的，毕竟读写磁盘（需要进入内核的一种情况）是绝对不能放弃的~~（谁能拒绝给磁盘里塞（）（）（）呢）~~，这时候用户必定要狠狠访问内核，但又不能直接进去，这时候就要请出大法：**跳板函数** 了。
		- syscall.c和syscall.h分别放着系统调用的具体代码和他们的调用名字（函数名）表，在你需要加入系统调用的时候就必须在两个里面都写好~~（不要生黑户）~~。还有sysinfo.h文件里面也要加声明（坑）
		- 但是系统调用是有这个娃（函数）了，也在.h文件里面编号（上户）了，可我用户怎么知道，难不成去开挂抢~~（潜入办公室）~~？这时候就要有syscall.c里面的extern 全局声明了:
		> 	用 extern 全局声明新的内核调用函数，并且在 syscalls 映射表中，加入从前面定义的编号到系统调用函数指针的映射extern uint64 sys_trace(void);   [SYS_trace] sys_trace,
		- 当然还没完，在usys.pl里面还要加入用户态到内核态的跳板函数：
		> 	这个脚本在运行后会生成 usys.S 汇编文件，里面定义了每个 system call 的用户态跳板函数 entry("函数名");
		- 还没完啊还没完，在用户态的头文件user.h加入定义，使得用户态程序可以找到这个跳板入口函数。int 函数名(int);
	- 这下子完成了，总结起来就是：
	> 	user/user.h: 用户态程序调用跳板函数 trace() 
	> 	user/usys.S: 跳板函数 trace() 使用 CPU 提供的 ecall 指令，调用到内核态 
	> 	kernel/syscall.c 到达内核态统一系统调用处理函数 syscall()，所有系统调用都会跳到这里来处理。
	> 	kernel/syscall.c syscall() 根据跳板传进来的系统调用编号，查询 syscalls[] 表，找到对应的内核函数并调用。 
	> 	kernel/sysproc.c 到达 sys_trace() 函数，执行具体内核操作
	- 说人话版：用户态下查表找到要调用的内核函数名字，让跳板函数带着这个名字跳进内核态统一处理，到内核态以后再查表，查到以后就可以调用了~~（是不是很简单）~~
	>	这么繁琐的调用流程的主要目的是实现用户态和内核态的良好隔离。
	>	并且由于内核与用户进程的页表不同，寄存器也不互通，所以参数无法直接通过 C 语言参数的形式传过来，而是需要使用 argaddr、argint、argstr 等系列函数，从进程的 trapframe 中读取用户进程寄存器中的参数。
	>	同时由于页表不同，指针也不能直接互通访问（也就是内核不能直接对用户态传进来的指针进行解引用），而是需要使用 copyin、copyout 方法结合进程的页表，才能顺利找到用户态指针（逻辑地址）对应的物理内存地址。（在本 lab 第二个实验会用到）
- 少年啊，你已经知道这些文件里面的函数是如何串起来的了，但是似乎少了些什么，对！我们现在知道的只是基于xv6跑起来以后的事，但是它是如何从未读取的硬盘数据跑起来的呢？（[课程3.9](https://mit-public-courses-cn-translatio.gitbook.io/mit6-s081/lec03-os-organization-and-system-calls/3.9-xv6-qi-dong-guo-cheng)部分和[附录 B：引导加载器](https://xv6-chinese.readthedocs.io/zh/latest/docs/AppendixB.html)有详细说明，以下只是基于我个人理解的总结）
	> 当我们启动电脑，内存会加载硬盘上固定位置的一段代码（BOIS），它会检查你PC的全身硬件，然后把另一段（操作系统斟茶兵 boot loader）加载到内存中，然后斟茶兵会把系统内核从硬盘上再拉到内存里开始运行。（省略了所有细节，请详细学习上述两链接内容！）
	> 内核有了，下一步就要创建用户态程序了，毕竟不能让你霍霍内核（乐），userinit会创建初始进程并返回用户空间，（此处省去巴拉巴拉调用）然后你的shell就运行起来了。（突兀的结束）
- 什么，太长不看？(っ °Д °;)っ
省流版：你的PC调用了一堆被按照要求整理好的文件。

## 2. 从水下第一个生命的萌芽开始……到内存控制🤪
~~（然后这就是lab3)的内容~~
- 如果说前两个实验是让你概览，那么下一个就是从内存的第一块数据说起了
	- xv6辣么多代码，他是怎么储存的呢，又是如何给每个运行的程序分配内存的呢：
		>	RISC-V 的逻辑地址寻址是采用三级页表的形式，9 bit 一级索引找到二级页表，9 bit 二级索引找到三级页表，9 bit 三级索引找到内存页，最低 12 bit 为页内偏移（即一个页 4096 bytes）。
	-  按照要求来，让我们扒开他的三级页表看看 ![[f2-1.png]]
	- 好复杂，看不懂怎么办，那就请阅读[xv6book 页表](https://xv6-chinese.readthedocs.io/zh/latest/docs/chapter2.html) 。其实就是上半张图，三个箭头从左到右理解为目录一，目录二，偏移量（行数/字数位置）即可。
- 你都知道他里面是什么东西了，这不自己做一个试试？要知道，原本的xv6里面是全家共享的页表**（用户进程在用户态使用各自的用户态页表，但是一旦进入内核态（例如使用了系统调用），则切换到内核页表，每个进程的页表同时包括用户内存和内核内存的映射，这样当用户通过中断或者系统调用转入内核时就不需要进行页表的转换了。大多数情况下，内核都没有自己的页表，所以内核几乎都是在借用用户进程的页表。）** ~~进程长大了给孩子留点隐私吧~~，下个部分就是让每一个进程进入内核态后，都能有自己的独立**内核页表**
	- 众所周知，C语言想组织起有联系的数据就会用结构体，既然这样，在进程的结构体里面加上独属于它的内核页表~~（房间）~~不就可以了吗？
	- 但是问题是：原本的房子（内存分配）是没有这种考虑的，而内存分配是要由系统帮助的，那么我们就去自己加上（大改）分配函数。
		>内核需要依赖内核页表内一些固定的映射的存在才能正常工作，例如 UART 控制、硬盘界面、中断控制等。而 kvminit 原本只为全局内核页表 kernel_pagetable 添加这些映射。我们抽象出来一个可以为任何我们自己创建的内核页表添加这些映射的函数 kvm_map_pagetable()。
		>(我是完全不懂，难绷)
	- 我们写好了分配函数，但是 这只是在用户态情况下的内存分配，当一个线程进入内核时，由于之前提到的**全家共享**的问题，内核栈也是会被共享的，所以我们要利用之前分配的内核页表
		> 由于 xv6 支持多核/多进程调度，同一时间可能会有多个进程处于内核态，所以需要对所有处于内核态的进程创建其独立的内核态内的栈，也就是内核栈，供给其内核态代码执行过程。
		> 在 xv6 原来的设计中，内核页表本来是只有一个的，所有进程共用，所以需要为不同进程创建多个内核栈，并 map 到不同位置（见 `procinit()` 和 `KSTACK` 宏）。而我们的新设计中，每一个进程都会有自己独立的内核页表，并且每个进程也只需要访问自己的内核栈，而不需要能够访问所有 64 个进程的内核栈。所以可以将所有进程的内核栈 map 到其**各自内核页表内的固定位置**（不同页表内的同一逻辑地址，指向不同物理内存）。
- ~~再下一个part完全没写，就不继续误人子弟了（当然未来哪一天我也许会回来填坑）~~

## 3. L属性大爆发！Lazy！懒是如何提高效率的(￣o￣) . z Z
- 上一个部分里面提到，每个线程都有一个独属于自己的空间，无论是在内核态还是用户态，但是内核态下有人管着它，用户态可就自由发挥了，但是我可怜的电脑只有那么一点点内存，被坏蛋线程霍霍了怎么办？这时候就要主打一个**懒** ，和我申请内存还不实际使用是吧~~（买房不住拿来抄啊）~~，那我就不实际分配~~（什么叫用时方恨少）~~，当实际使用时再分配。
	- PS: 这里就要提到来自外星（划掉）的技术：[[#4. 全都是泡沫~ 假假假，系统为了隔离骗了多少进程😁]]。
	>实现一个内存页懒分配机制，在调用 sbrk() 的时候，不立即分配内存，而是只作记录。在访问到这一部分内存的时候才进行实际的物理内存分配。
- 光是线程内存页懒可不够，要做就做的更狠，干脆在进程fork之后就开摆
	 >实现 fork 懒复制机制，在进程 fork 后，不立刻复制内存页，而是将虚拟地址指向与父进程相同的物理地址。在父子任意一方尝试对内存页进行修改时，才对内存页进行复制。 物理内存页必须保证在所有引用都消失后才能被释放，这里需要有引用计数机制。
- 也许你看到这里会问：就这俩摆了有什么用呢，我前面提过：电脑的内存可是很小的，这里的内存不止指DARM，还有SRAM（就是CPU的小闺房），如果为了一个不一定下一步要运行的程序加载一大堆东西或者给他分配一大堆位置，岂不是很亏~~（既骗感情又骗钱）~~。所以内存页懒分配做到了不分配内存， fork 懒复制做到了不立刻复制内存页，他们都被许下了一个未来可欺的承诺，只有哭哭（真要开始用内存的时候）才会被兑现。
	- ~~（这里似乎还要写啥，暂时没头绪就占着）~~

## 4. 全都是泡沫~ 假假假，系统为了虚拟骗了多少进程😁
- 内存要骗，CPU资源要骗，怎么电子世界都没有信任？但是你也不想辣么贵的电脑只能同时运行一个程序然后你在它面前干巴巴的等着吧~ ，这个时候虚拟的作用就体现出来了
	- > 实现一个用户态的线程库；尝试使用线程来为程序提速；并且尝试实现一个同步屏障。
	>	这里的线程相比现代操作系统中的线程而言，更接近一些语言中的“协程”（coroutine）。原因是这里的“线程”是完全用户态实现的，多个线程也只能运行在一个 CPU 上，并且没有时钟中断来强制执行调度，需要线程函数本身在合适的时候主动 yield 释放 CPU。这样实现起来的线程并不对线程函数透明，所以比起操作系统的线程而言更接近 coroutine。
- 啊，你巴拉巴拉这么大一堆和虚拟有什么关系呢？关系大了！
	- 1. 对于CPU来说，进程到底是什么呢？是一个只在系统里区分不同程序的东西吗？概括着具体来说，**进程是一个状态机**，一个进程包含着他此时的运行状态和他手里握着的数据，这些东西对于CPU——这个拿（进程）来（运行）主义者来说，就是一个自动备忘录，存着接下来CPU要做的所有事情，那么相对于CPU，他只需要运行，下一个，运行......即可，很符合它的形象嘛。
			- 当然没完，进程既然要保存这么多东西，他是如何找到那么大的连续空间来存放他的数据的呢？总不能东一块西一块自己记着吧~~（你的橡皮擦掉了）~~，这时候我们上面提过的机制：页表 就派上用场了，每次进程增加要占用的地方，~~系统总不能说：去去去没地方了自己崩溃去~~，就可以通过页表帮忙记录他零零碎碎申请下来的空间，帮大忙了！现在即使不是真正意义上的连续大空间，但是页表的帮忙实现了一种虚假的~~繁荣~~连续，让进程可以舒舒服服的被骗，沉沦在虚拟化内存的温柔乡中。
	- 2. 对进程来说，CPU又是什么东西呢，总不能是~~到点下班的xx~~无情海王吧。当然也大差不差，进程为了让自己手里的数据按照要求处理，只能干巴巴的排队，为了解决这种情况，他们决定隐藏自己（的细节），让CPU成为纯粹的工具U，在[[各种调度策略下]]挨个给他们处理数据就好啦。
	- 3. 他们各自的视角有了，那我们不妨拉远视角看看。CPU被虚拟化后，每个线程都认为自己有一个独属于自己的处理器（可惜被骗让出后只能抱着自己的状态哭唧唧），线程被虚拟化后，有了一个连续的大房子放他的七零八碎。皆大欢喜不是吗（￣︶￣）↗　
- 虚拟当然不止为了相互欺骗，这样做可是完成了相互隔离，从而实现安全和并发（并行）的目标。
	- 为什么安全？通过页表（实际上应该不止，还有分段，分页什么的~~脑子烧了~~）给每个进程创造了一个独属于他们的空间并且互不干涉，这样一来~~外来邪恶势力~~就不能随意相互访问或者修改别人的空间了。
	- 如何并发（并行）？既然每个进程都能自行保存自己的状态，那我CPU可不客气了，拿这个进程聊聊，拿那个进程玩玩，在调度策略下雨露均沾，每个进程似乎都以近似的速度完成了他们各自的目标（实际上有更复杂的机制，这里只说了在单核CPU下的简单调度情况），最终显示在你屏幕面前就是几个程序”看似“同时完成工作。
概括来讲，虚拟也是一种相互的抽象，简化了对于不同组件要面对的复杂问题，从而实现更高级的功能。

## 5. 红尘茫茫，你是我的Master吗？--来自锁的灵魂发问🤩
>Lab 8: Locks：重新设计代码以降低锁竞争，提高多核机器上系统的并行性。
- 上面我们提到了在”**调度策略**“下，每个进程似乎都以近似的速度完成了他们各自的目标。但是你有没有想过这样一个问题：要是有两个进程要访问一个东西呢？~~（爱上了同一个人）~~，这时候总不能让他们随便访问了吧，这个”共享空间“怎么说也要独占！霸占！而这就是**锁**。
- 本lab的实验是拆分锁，但是我偏要多讲点：什么大锁小锁？
	- 实际上，大锁没什么不好的，毕竟那么多进程要追求一个资源，我总不能一个一个拦着吧，而且他们各自又有什么不同的细致需求我才懒得管，这也是一个很重要的思想：**「过早优化是万恶之源」** ，当我给这个共享资源挂上一个大锁，无论你进去想1+1还是9* 9 都要拿着这个锁对应的钥匙再进去干活，这也造成了另一个隐患：竞争访问。
	- 竞争访问，也就是对一个资源访问量过大时，这个资源就成了所谓*热点*
	- >这里解决性能热点的思路是「将共享资源变为不共享资源」。锁竞争优化一般有几个思路：
	>	- 只在必须共享的时候共享（对应为将资源从 CPU 共享拆分为每个 CPU 独立）
	>	- 必须共享时，尽量减少在关键区中停留的时间（对应“大锁化小锁”，降低锁的粒度）
	- 好，那我要把大锁拆掉放小锁了，但是给谁放，放在哪，如何获取锁呢？要知道，为了防止一个贪婪的线程拿着一堆钥匙把自己绕晕在锁里，我们要知道：
		- >死锁的四个条件：
		-1. 互斥（一个资源在任何时候只能属于一个线程）
		-2. 请求保持（线程在拿着一个锁的情况下，去申请另一个锁）
		-3. 不剥夺（外力不强制剥夺一个线程已经拥有的资源）
		-4. 环路等待（请求资源的顺序形成了一个环）
		只要破坏了四个条件中的任何一个，就能破坏死锁。
	- 哇，怎么要考虑这么多东西，我只是想让一个共享资源被安全共享而已！是这样的，所以我们这次就lab论lab来看看这些理论是如何在实际上运用的：
		- part1：通过拆分 kmem 中的空闲内存链表，降低 kalloc 实现中的 kmem 锁竞争。嗯，很应景，毕竟刚刚才说过......
			- 这里的情景概括来说就是：多个进程要同时申请物理页，但是这个物理页的使用情况被放在链表上储存，为了安全修改，每次分配或者释放物理页都要获得锁后才能修改这个链表，这也导致一堆进程排队等着锁~~（莫名公厕排队）~~。
			- 这时我们回顾前面的热点解决思路，如果我们把这个链表从共享于多个CPU改成各个CPU都有一个这样的链表，是不是就能在一定程度上降低同时访问造成的等待呢？
			- 当然，每个CPU的链表总有要用完的一天，这个时候去隔壁“借”~~偷~~不就行了嘛，所以仍然要加锁，当然这次就不给全局加锁了，给每个CPU的表各加一个就成，毕竟谁访问不是访问呢😂
			- ps：这里事实上在我的参考文章中出现了一些值得讨论的很有意思的情况，请自行移步[posts/s081-lab8-locks/ · Issue #8 · Miigon/blog (github.com)](https://github.com/Miigon/blog/issues/8)
		- part2：多个进程同时使用文件系统的时候，bcache.lock 上会发生严重的锁竞争。bcache.lock 锁用于保护磁盘区块缓存，在原本的设计中，由于该锁的存在，多个进程不能同时操作（申请、释放）磁盘缓存。依然是我们上面讨论过的......乐
			- 我当时是利用AI讨论了一些情况，但是会更加提高了锁的复杂度，就按下不表了。~~（主要是找不到聊天记录了）~~原作者采用的是检查锁->释放原锁偷内存->再次检查 获锁后成功偷取  的思路。
			- 这里我还是推荐到我的参考文章作者那里看详细推导过程：[[mit6.s081] 笔记 Lab8: Locks | 锁优化 - 掘金 (juejin.cn)](https://juejin.cn/post/7021218568226209828)
	用OSTEP里面的话结尾：那么，你现在头疼吗？
## 6. 刻在石头上才是最永久的浪漫--文件当然不在石头上🤔
- 弯弯绕绕半天，我们知道了系统里最活跃的线程是怎么带着信息处理~~被骗~~的，但是他带着的信息不会丢吗？毕竟内存是易失介质，那就只能在活跃完回到硬盘老家的时候好好保存他们的信息了。就是说，有没有可能，他们回家就变成了我们一开始看到还会挠头的一堆**文件**。
- 作为一个个乖宝宝文件，最大的要求就是不能丢，而且召之即来，但是辣么多文件宝宝可让系统犯了难，总不能一个一个顺序查找~~大海捞针~~吧，这个时候，辣个地外科技：**页表** 就要再次出马了。
	- 现在我们要考虑如何组织这些文件宝宝并且让他们方便于系统访问，那么首先要考虑的就是~~中国宝宝的体质~~ 文件系统的数据结构，他们是链表？是树？还是什么奇奇怪怪的样子，组织（数据）结构决定了我们如何访问他们。
	- 访问不同数据结构的宝宝当然有不同的方式，毕竟用户态的进程得通过系统调用[[#^4ea47d]]访问，系统调用的笨蛋函数当然不会知道什么特别复杂的事，所以这就得我们考虑：
		> 文件系统的心智模型：对于文件系统，你的心智模型最终应包含以下问题的答案：磁盘（硬盘）上的哪些结构储存文件系统的数据和元数据？当一个进程打开一个文件时会发生什么？在读取或写入期间访问哪些磁盘结构？
	- 看起来很抽象对不对？那我们再次祭出这张图：![[f2-1.png]]
	- 当然我是觉得他不够详细，那就换两张看看（来自OSTEP 40：文件系统实现）： ![[Pasted image 20230620093528.png]]![[Pasted image 20230620093600.png]]
		-  注：S - Super block 超级块 | i - inode （index node）索引节点 | d - data bit map 数据位图 | D - data region 数据区域（数据块）
		- 我们现在当然不想找很难很精妙的结构来学，除了让人直呼内行以外并没有什么用。所以我们来点暴力简单的：按照~~数组~~（数据块）的方式一块一块把文件放好，大体上看着就是上图一：前面0-7区域放*元数据*（相当于目录的作用），后面所有的空放具体内容。
		- 当然，系统调用的笨蛋函数不管这么多~~（再次）~~ ，毕竟我们翻书查资料也是从目录看起吧~~（我还就喜欢直接找内容）~~，访问文件系统也一样：**从页表查起，得到一级，二级...目录，通过目录+偏移量（上上图offset）找到数据块，通过数据块的前几个*元数据*再找到具体的data位置**。~~嗯，有小时候翻新华字典疯狂跳转那味儿了~~
		- 读写当然是相通的，毕竟都要找一个特殊的（天选之块）来访问/写入 数据。那他们是怎么知道哪个小块（iblock）的使用情况呢？其实*元数据*里面就已经存好辣~~（是不是很贴心）~~，至于他们里面具体有什么，请自行查看[OSTEP 40：文件系统实现](https://pages.cs.wisc.edu/~remzi/OSTEP/file-implementation.pdf) 。
	- 上面以OSTEP为基础的介绍部分是VSFS文件系统的概况，而xv6文件系统类似于FAT文件系统
		- > xv6 文件系统中的每一个 inode 结构体中，采用了**混合索引**的方式记录数据的所在具体盘块号。每个文件所占用的前 12 个盘块的盘块号是直接记录在 inode 中的（每个盘块 1024 字节），所以对于任何文件的前 12 KB 数据，都可以通过访问 inode 直接得到盘块号。这一部分称为直接记录盘块。
		- >对于大于 12 个盘块的文件，大于 12 个盘块的部分，会分配一个额外的一级索引表（一盘块大小，1024Byte），用于存储这部分数据的所在盘块号。
		- 好复杂对吧，那就看看大神的图片：![[Pasted image 20230620100020.png]]
		- 其实也就是我上面粗体所说的方式，通过一级一级的目录访问。当然你读到这里会问：为什么要设计这么多级的目录呢？~~（我早应该解释才对）~~很简单，你不想翻目录也像翻内容一样困难吧，那就把目录也加一个目录（提高抽象层次），你去翻最概括最精炼的目录不就简单了嘛~
	- 现在我们有了完备的上门访问数据的机制，但是有没有可能，有些文件他们是一家人呢，就是他们打开后都指向一个位置的一个数据~~（这是你吗？是的，那时候我还很瘦）~~ ，这下没必要给他们一人一间了吧，那该怎么做呢？
		- 这里我要提到两个词：硬链接和符号链接。他们的详细功能可以在[OSTEP 39](https://pages.cs.wisc.edu/~remzi/OSTEP/file-intro.pdf)里面找到，我概况如下：
			- 硬链接：创建快捷方式
			- 符号链接（软链接）：将链接指向文件的路径名作为链接文件的数据。
		- 当然你的lab9 part2就是让你创建符号链接啦~
	那时我还很年轻，直到掌握了一门黑魔法：文件系统
	~~ps：这里应该还要写文件持久化和分布式的东西的，但是还没啥头绪就先空着了~~
## 7. 少年，你得到了什么，那代价呢？🧐
- 我并没有完完整整的自己写完所有实验，反而是在或重或轻的点上左顾右盼，翻完几本操作系统有关的书似乎懂了，又似乎没懂，但也乐在其中而已
- 感谢开源社区和网络共享资源的帮助，以下是我主要用到或引用的文章：
	- [[mit6.s081] 笔记 课程总结 & Lab 指北 - 掘金 (juejin.cn)](https://juejin.cn/post/7024644053996142605)
 	- [MIT 6.S081 xv6调试不完全指北](https://www.cnblogs.com/KatyuMarisaBlog/p/13727565.html)
	- OSTEP
	- CSAPP
	- Linux Kernel Development

本篇文章是我用一鲲月做完（大体做完）mit6.s081 lab 后才动笔（键盘）写的，有许多细节和感悟可能已经忘掉，或者会出现很多错误，欢迎在github上提lssues，我看到会回复/修改的（嗯！）。之后这篇文章可能会继续更新，或者另外写一篇以linux为讨论点的文章，~~star够多肯定会写~~，期待您的star~
